A more efficient way of testing would prepare all possible combinations of the four changes enabled or disabled. 
That is 2^4 = 16 engines. You let each engine play the same gauntlet of 400 games. That is only 6400 games in total. 
Now for any of the four changes there are 8 engines that had the change, and 8 that had not. So you have played 
3200 games with the change enabled, and 3200 games with that change disabled. The statistical error in each of these 
3200-game totalled results is sqrt(0.5)% (=40%/sqrt(3200)), the statistical error in the difference is 1%, as desired. 
The fact that not all of the 3200 games were obtained with the same setting of the other changes does not affect 
the outcome (if the changes are independent and lead to additive improvement), as the reference had exactly the same
mix of settings of the other changes. This is similar to testing against a number of different opponents to get more
independent games, you can just as well play with a few different versions of the engine-under-test to create more diversity.

With this method you test 4 changes to the same accuracy with the same number of games as you would have tested 
a single change! In other words, you tested 3 changes for free! And it does not stop there: you could just as easily
have evaluated 6 changes to 1% accuracy in those 6400 games, by making 64 versions of your engine and have each play 
100-game gauntlets.

This really is a big time saver! 

(Harm-Gert Muller)

---------------------------------------------------------------------------------------------------------------------

 TODO: feeding pv moves back into TT (Stockfish)
 TODO: don't prune moves that escape from null move threat                              
                                             
---------------------------------------------------------------------------

TO TEST: different set of values for delta pruning

  Let us declare array int PrunePiece[7] indexed by piece type and initialize it as :
 PrunePiece[0] = 160;
 PrunePiece[1] = 500;
 PrunePiece[2] = 500;
 PrunePiece[3] = 800;
 PrunePiece[4] = INFINITY; // Queen is not delta pruned at all
 PrunePiece[5] = -INFINITY; // irrelevant, king can not be captured,we never will arrive to this position
 PrunePiece[6] = 160; // ??? move is not capture,maybe en passant capture

-------------------------------------------------------------------------------------------------------


TO TEST AGAIN (earlier attempt lost due to rollback, though explicit setting of delta added)
      
  About   // DELTA PRUNING in file quiescence.c
     
   When doing delta pruning it is better not to prune promotions into queen.
 If we are capturing and promoting to queen when this move is very,very strong and
 can not be pruned. 
 Function int *GenerateCaptures(sPosition *p, int *list) generates captures,but it
 also generates and promotions.So move can be capture and promotion at the same time.
 Such a moves are dangerous and can not be delta pruned.
 In Rodent is function MoveType(x).
 So if ( MoveType(move) != Q_PROM ) delta prune.
    if ( MoveType(move) == Q_PROM ) do not delta prune.

  Delta pruning is often done only when alpha + 1 == beta, IE in non PV nodes.But
 in PV nodes can also be done ,but has nuances.In my opinion in PV nodes delta
 pruning should be avoided.

  In delta pruning should be p->pieceMat[p->side] > 500 IE side to move 
 must have more than rook of piece material ( not counting pawns ).
   Also when in check delta prune is non sense.But in Rodent this is irrelevant,
 because when in check Rodent's Quiesce performs poorly anyway.
 
-------------------------------------------------------------------------------------------- 
 
 TO TEST
 
 You have:

 best = Eval.Return(p, alpha, beta);
 ................. ( skipped fragment )
 if ( best + victimValue + Data.deltaMargin < alpha                
 && Data.useDeltaPruning )                   
        continue;                                      // whatever the gain, move will not help

 Above statement is correct if we are considering first
 capture from move list ( IE first move ).But if we are
 considering not first move when it is quite possible that
 variable 'best' already is bigger than Eval.return( p, alpha, beta)
 because 'best' has trend to grow up.And if it is so,when
 expression
 'best + victimValue + Data.deltaMargin'
 will be too big  ( for the not first move,because
 best can be rised up by first move(s), but this
 current, not first move has "nothing in common "
 with this rised up best by first move(s) ). 

 Here is corrected version:
 int StaticEval; // additional variable
 best = StaticEval = Eval.Return(p, alpha, beta);
 ................. ( skipped fragment )
 if ( StaticEval + victimValue + Data.deltaMargin < alpha                
 && Data.useDeltaPruning )                   
         continue;                                      // whatever the gain, move will not help

-----------------------------------------------------------------------------------------

TO CHECK

     About function int IsLegal(sPosition *p, int move) in file legal.c .
 Firstly we can add this line :
  // cannot capture king
  if ( ttp != NO_TP && ttp == K )
    return 0;
 This is not paranoia ,because theoretically this paranormality can be reached.

------------------------------------------------------------------------------------------------------------

     
  TO TEST   
     
     About function int sEvaluator::AdjustMaterial(sPosition *p) in file eval_material.c .
  I suggest this :

  if ( p->pcMat[WHITE]+ p->pcMat[BLACK] == 0 )
     result += ( p->pcCount[WHITE][P] -  p->pcCount[BLACK][P] ) *100;
     
  [code simplified - PK]  

  These are endgames when only pawns on board are left.In these cases
  having 1,2... pawns more than opponent is often decisive advantage.That's
  why  pawn's difference is multiplied by 100.
   Otherwise function int sEvaluator::GetMaterialScore(sPosition *p)  
  will count:
  score += pawnMat[p->pcCount[WHITE][P]];
  score -= pawnMat[p->pcCount[BLACK][P]];
  here uses :
  static const int pawnMat[9] = {-40, 90, 180, 270, 360, 450, 540, 630, 720};

  If white side has only 1 pawn and black side has only 2 pawns left then
  score += 90;
  score -= 180;
  And finally score -= 90;

  In above definition score will be decreased by 190 instead 90.This
  material score is more objective when there are only pawns left on the
  board.This modification can give approximately 17 Elo points.

  Also this trick is described in Ed Schroder programming tutorial where
 he describes Rebel chess engine.There is chapter called Pawn Ending.
   Below I made short extract from this tutorial:
       ---
 Rule no. 1 in pawn endings : the side with a pawn up will win the game.
 The below code ( or something similar ) is a must in every chess program:
  int pawn[] = { 0x00,0x00,0x100,0x200,0x300,0x400,0x500,0x600,0x700 };
  if (pawn_ending) 
   { score=score+pawn[number_of_white_pawns];
     score=score-pawn[number_of_black_pawns];
   }
 Effect : the difference in pawns is the bonus in pawns.
 Remark : the rule does not function in case of isolated double pawns,
 special code is needed to count isolated double pawns as 1 pawn before
 using the above formula.
      ---
 In essence this is the same bonus as I described above.In Rodent
 in case of pawn endgame array
 static const int pawnMat[9] = {-40, 90, 180, 270, 360, 450, 540, 630, 720};
 should be declared as :
 static const int Endgame_pawnMat[9] = { 0x00,0x00,0x100,0x200,0x300,0x400,0x500,0x600,0x700 };
 And latter array will be used when no other than pawns material is left on board.
 This case can be called 'peshechnik' in Russian language.
----------------------------------------------------------------------------------------------

   TO TEST

   Also when move is castle we update pstMg :
   p->pstMg[side] += Data.pstMg[side][R][tsq] - Data.pstMg[side][R][fsq];
   Here some bonuses can be added to pstMg in order to encourage castling.
   For instance :
   p->pstMg[side] += 20; // for long castling move O-O-O
   p->pstMg[side] += 30; // for short castling move O-O
   When undoing castle move these bonuses should be substracted of course.
   For p->pstEg[side] ( pst for Endgame ) bonuses are not given.
  
--------------------------------------------------------------------------------------------------------------

TO READ

  In file parser.c we have :
  void sParser::ParseGo(sPosition *p, char *ptr)
     {
  char token[80], bestmoveString[6];
  int pv[MAX_PLY];
  // TODO: move PV to search class
 .....................................
  Here is declared array pv[MAX_PLY].
 And below in the same function we have call :
 Searcher.Think(p, pv);
 Function Think is declared as :
 void sSearcher::Think(sPosition *p, int *pv)
 {
 ......................................
 Call Searcher.Think(p, pv) can be rewritten
 as Searcher.Think(p,&pv[0]), because pv is the
 same as &pv[0] and this &pv[0]is simply machine address.
 Only computer knows this &pv[0] value exactly.
 From Think we call function Iterate(p, pv).
 And from Iterate we call Search(p,0,........,pv ).
 So in Search when ply == 0 ( we are at the root )
 parameter int *pv will be initialized to pv, ie
 to &pv[0].Now when *pv is initialized to &pv[0],
 then pv will be equal to &pv[0] and *pv will be
 equal to value stored at this machine address (
 at pv or at &pv[0] ).In fact *pv will be equal to pv[0],
 ie *pv will be uninitialized, because array pv[] is uninitialized
 and pv[0],pv[1],... are all uninitialized.So *pv can be 0 ,but can be != 0.
 In order to test this theory I suggest to add debugging
 line(s) in function Search after line if (ply) *pv = 0; :
 if (ply) *pv = 0;
 if ( ply == 0 ) assert( *pv == 0 ); // debug
 or
 if (ply) *pv = 0;
 if ( ply == 0 )
 if ( *pv != 0 ) exit(0); // debug
  This test is needed because of the following reason:
 if at root ( when ply == 0 ) already *pv != 0 when 
 if at root search fails low then this *pv will remain
 non zero anyway ,ie will remain *pv != 0 and saving code will
 be incorrect,because *pv will be rubbish,and we will save
 fail low node as EXACT.
  // SAVE SEARCH RESULT IN TRANSPOSITION TABLE
  if (*pv) {
	History.OnGoodMove(p, *pv, depth / ONE_PLY, ply);
      TransTable.Store(p->hashKey, *pv, best, EXACT, depth, ply);
           }
      .........................
  Maybe array int pv[MAX_PLY] should be cleared ( all values set to
  0 ) after initialization.
  Or instead of 'if (ply) *pv = 0' write simply *pv = 0.
-------------------------------------------------------------------------------------------------------