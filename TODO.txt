A more efficient way of testing would prepare all possible combinations of the four changes enabled or disabled. 
That is 2^4 = 16 engines. You let each engine play the same gauntlet of 400 games. That is only 6400 games in total. 
Now for any of the four changes there are 8 engines that had the change, and 8 that had not. So you have played 
3200 games with the change enabled, and 3200 games with that change disabled. The statistical error in each of these 
3200-game totalled results is sqrt(0.5)% (=40%/sqrt(3200)), the statistical error in the difference is 1%, as desired. 
The fact that not all of the 3200 games were obtained with the same setting of the other changes does not affect 
the outcome (if the changes are independent and lead to additive improvement), as the reference had exactly the same
mix of settings of the other changes. This is similar to testing against a number of different opponents to get more
independent games, you can just as well play with a few different versions of the engine-under-test to create more diversity.

With this method you test 4 changes to the same accuracy with the same number of games as you would have tested 
a single change! In other words, you tested 3 changes for free! And it does not stop there: you could just as easily
have evaluated 6 changes to 1% accuracy in those 6400 games, by making 64 versions of your engine and have each play 
100-game gauntlets.

This really is a big time saver! 

(Harm-Gert Muller)

---------------------------------------------------------------------------------------------------------------------

 TODO: attacks on pieces
 TODO: root move list and more elaborate sorting thereof
 TODO: feeding pv moves back into TT (Stockfish)
 TODO: don't prune moves that escape from null move threat
 TODO: extend passed pawn pushes to 7th rank
 
------------------------------------------------------------------------
Hyatt: 

Here is the easiest way to deal with this, although this applies to a normal alpha-beta search (PVS changes this a bit). 
The root node is always an ALL node. The first node searched below an ALL node is also an ALL node. Except for this 
first node below an ALL node, all other nodes immediately below an ALL node are CUT nodes. It is simple after that. 
If a node follows an ALL node, it is a CUT node. If a node follows a CUT node, it is an ALL node.
If you want to factor in PV nodes, then we can change that to this:

The root node is a PV node. The first successor of a PV node is always a PV node. Other successors 
of a PV node are CUT nodes. And as before, any successor of an ALL node is a CUT node and vice-versa. 
If you traverse the tree in the usual left-to-right graph, the left edge of the graph contains the PV nodes. 
There are no others unless move ordering is incorrect...
 

------------------------------------------------------------------------

in ScoreB()

	if ( bbPc(p, side, B) & bbTrap[side] ) {
    if ( ( sq == relativeSq[side][A7] ) && ( bbPc(p, Opp(side), P) & SqBb(relativeSq[side][B6]) ) ) AddMiscOne(side, - 150);
    if ( ( sq == relativeSq[side][B8] ) && ( bbPc(p, Opp(side), P) & SqBb(relativeSq[side][C7]) ) ) AddMiscOne(side, - 150);
    if ( ( sq == relativeSq[side][H7] ) && ( bbPc(p, Opp(side), P) & SqBb(relativeSq[side][G6]) ) ) AddMiscOne(side, - 150);
    if ( ( sq == relativeSq[side][G8] ) && ( bbPc(p, Opp(side), P) & SqBb(relativeSq[side][F7]) ) ) AddMiscOne(side, - 150);
    if ( ( sq == relativeSq[side][A6] ) && ( bbPc(p, Opp(side), P) & SqBb(relativeSq[side][B5]) ) ) AddMiscOne(side, - 50);
    if ( ( sq == relativeSq[side][H6] ) && ( bbPc(p, Opp(side), P) & SqBb(relativeSq[side][G5]) ) ) AddMiscOne(side, - 50);
  }                                      
                                             
---------------------------------------------------------------------------

TO TEST: different set of values for delta pruning

  Let us declare array int PrunePiece[7] indexed by piece type and initialize it as :
 PrunePiece[0] = 160;
 PrunePiece[1] = 500;
 PrunePiece[2] = 500;
 PrunePiece[3] = 800;
 PrunePiece[4] = INFINITY; // Queen is not delta pruned at all
 PrunePiece[5] = -INFINITY; // irrelevant, king can not be captured,we never will arrive to this position
 PrunePiece[6] = 160; // ??? move is not capture,maybe en passant capture

---------------------------------------------------------------------------

TO TEST

I suggest this :
void sSearcher::Iterate(sPosition *p, int *pv) {
  int val = 0;
  int curVal;
  int aspiration;

  isReporting = 1; // otherwise rejected book move causes crash 

  int localDepth = AdjustRootDepth(p); // get search depth (reducing it in case of one legal move)
  Timer.SetIterationTiming();          // define additional rules for starting next iteration
  Data.InitAsymmetric(p->side);        // set asymmetric eval parameters, dependent on the side to move
  Timer.SetData(FLAG_ROOT_FAIL_LOW, 0);

  for (rootDepth = ONE_PLY; rootDepth <= localDepth; rootDepth+=ONE_PLY) {

	 DisplayRootInfo();
	 aspiration = Data.aspiration; // TODO: progressive widening loop
    
	// first use aspiration window around the value from the last completed depth
      if ( rootDepth >= 28 && val <= 25000 && -25000 <= val ){ // or rootDepth >= some minimal depth
      // which must be firstly completed in order to begin use aspiration window search
      // TODO: make sure here that val-aspiration >= -MATE and val+aspiration <= MATE
	curVal = Search(p, 0, val-aspiration, val+aspiration, rootDepth, IS_PV, NO_NULL, 0, pv);
	if (flagAbortSearch) break;

	// if score is outside the window, re-search
	if (curVal >= val+aspiration || curVal <= val-aspiration) 
	{
        // On a score drop it might be prudent to assign some more time 
		//(no gain from doing it from depth 6 onwards, no gain from curVal+10)
        if (curVal < val) Timer.SetData(FLAG_ROOT_FAIL_LOW, 1);

		curVal = Search(p, 0, val-3*aspiration, val+3*aspiration, rootDepth, IS_PV, NO_NULL, 0, pv);
        if (flagAbortSearch) break;

		// the second window
		if (curVal >= val+3*aspiration || curVal <= val-3*aspiration) 
            curVal = Search(p, 0, -INF, INF, rootDepth, IS_PV, NO_NULL, 0, pv);

        if (flagAbortSearch) break;
	}
        } // if ( rootDepth >= 28 )
      else{ //  if ( rootDepth < 28 ) - in first iterations we use full window -INF, INF
            // also when val already very high or very low - no windowing - full window
            curVal = Search(p, 0, -INF, INF, rootDepth, IS_PV, NO_NULL, 0, pv);
        if (flagAbortSearch) break;
          }

		if (Data.useLearning 
		&& !flagAbortSearch
		&& !Data.useWeakening
		&&  p->pieceMat[WHITE] > 2000 
		&&  p->pieceMat[BLACK] > 2000) 
			Learner.WriteLearnData(p->hashKey, rootDepth, curVal);


    // TO TEST: reseting FLAG_ROOT_FAIL_LOW after 3 iterations w/o fail low

	// abort root search if we don't expect to finish the next iteration
	if (Timer.FinishIteration() ) 
	{
		DisplaySavedIterationTime();
		break; 
	}

	val = curVal;
  }
  //printf("info string CHAT TEST \n");
}
Main idea is not to use aspiration in first [1;6] iterations.

 
------------------------------------------------------------------------------------
   Here is extract from Search function in search.c
  // at root we keep track whether a move has been found; if not, we let the engine
  // search for a bit longer, as this might indicate a fail-high/fail-low
  if (!ply && isPvNode) Timer.SetData(FLAG_NO_FIRST_MOVE, 1); // (1)
  and later in same code :
  if (!ply && isPvNode) Timer.SetData(FLAG_NO_FIRST_MOVE, 0); // (2)

  If !ply then => ply == 0, so we are at the root node.
  From Iterate you call Search as :
  curVal = Search(p, 0, -INF, INF, rootDepth, IS_PV, NO_NULL, 0, pv);
  So isPvNode will be equal to IS_PV ,so when ply == 0 then isPvNode will
  always be IS_PV ,ie always be 1.
  I think that if !ply then isPvNode always will be 1.So, condition isPvNode in
  composite condition (!ply && isPvNone) is redundant ?
  
  These commands (1) and (2) will not keep track whether a move has been found. 
  They simply will add more time for first move and will not add more time
  for the rest of the moves.Do you expect this ? In my opinion statements
  if (!ply && isPvNode) Timer.SetData(FLAG_NO_FIRST_MOVE, 0) should be in another place :
  ( if (score > alpha ) {
    if (!ply && isPvNode) 
    Timer.SetData(FLAG_NO_FIRST_MOVE, 0);
    alpha = score .....
    ...................
  when you really have found best move.

----------------------------------------------------------------------------------------

 About STATIC NULL MOVE.
Your code:
  // STATIC NULL MOVE (idea taken from Stockfish)

  if (Data.useNull
  && !isPvNode
  && depth <= Data.minimalNullDepth
  && !wasNull
  && beta < MAX_EVAL
  && !flagInCheck
  && p->pieceMat[p->side] > 325
  ) {
    int delta = 150 + 20*depth;
	if (beta + delta <= Eval.ReturnFast(p) )
	   return beta + delta; 
    
  } // end of static null move code 
 Here beta should be not too small.But this
 condition that beta > -10000 or beta > -MAX_EVAL is
 omitted in your code.Condition beta < MAX_EVAL is
 not very important and can be omitted.Most importantly
 beta > -10000.

-----------------------------------------------------------------------------------------------------

  TESTS ON A WIDER RANGE OF MACHINES ARE NEEDED 
  (on my old laptop remembering pst scores helps a bit)

  We have structure for undoing move:
 typedef struct 
{
  int ttp;
  int castleFlags;
  int epSquare;
  int reversibleMoves;
  U64 hashKey;
  U64 pawnKey;
} UNDO;

My question is - is it possible to add couple
variables to it ?.Let's say:
 typedef struct 
{
  int ttp;
  int castleFlags;
  int epSquare;
  int reversibleMoves;
  int staticEG,staticMG; // pst values endgame,midgame
  U64 hashKey;
  U64 pawnKey;
} UNDO;
And when DoMove
then to save current pstMg[side],pstEg[side] into
staticMG,staticEG.
And when UndoMove
then restore pstMg[side],pstEg[side] from staticMG,staticEG.
It is faster than to re-calculate pstMg[side],pstEg[side] again. 

-------------------------------------------------------------------------------------------------------


TO TEST AGAIN (earlier attempt lost due to rollback, though explicit setting of delta added)
      
  About   // DELTA PRUNING in file quiescence.c
     
   When doing delta pruning it is better not to prune promotions into queen.
 If we are capturing and promoting to queen when this move is very,very strong and
 can not be pruned. 
 Function int *GenerateCaptures(sPosition *p, int *list) generates captures,but it
 also generates and promotions.So move can be capture and promotion at the same time.
 Such a moves are dangerous and can not be delta pruned.
 In Rodent is function MoveType(x).
 So if ( MoveType(move) != Q_PROM ) delta prune.
    if ( MoveType(move) == Q_PROM ) do not delta prune.

  Delta pruning is often done only when alpha + 1 == beta, IE in non PV nodes.But
 in PV nodes can also be done ,but has nuances.In my opinion in PV nodes delta
 pruning should be avoided.

  In delta pruning should be p->pieceMat[p->side] > 500 IE side to move 
 must have more than rook of piece material ( not counting pawns ).
   Also when in check delta prune is non sense.But in Rodent this is irrelevant,
 because when in check Rodent's Quiesce performs poorly anyway.
 
-------------------------------------------------------------------------------------------- 
 
 TO TEST
 
 You have:

 best = Eval.Return(p, alpha, beta);
 ................. ( skipped fragment )
 if ( best + victimValue + Data.deltaMargin < alpha                
 && Data.useDeltaPruning )                   
        continue;                                      // whatever the gain, move will not help

 Above statement is correct if we are considering first
 capture from move list ( IE first move ).But if we are
 considering not first move when it is quite possible that
 variable 'best' already is bigger than Eval.return( p, alpha, beta)
 because 'best' has trend to grow up.And if it is so,when
 expression
 'best + victimValue + Data.deltaMargin'
 will be too big  ( for the not first move,because
 best can be rised up by first move(s), but this
 current, not first move has "nothing in common "
 with this rised up best by first move(s) ). 

 Here is corrected version:
 int StaticEval; // additional variable
 best = StaticEval = Eval.Return(p, alpha, beta);
 ................. ( skipped fragment )
 if ( StaticEval + victimValue + Data.deltaMargin < alpha                
 && Data.useDeltaPruning )                   
         continue;                                      // whatever the gain, move will not help

-----------------------------------------------------------------------------------------------------------
                              
      We have functions:
void sData::InitMaterialValues(void) 
{
	//             name,  val, pha, att
	 InitSinglePiece( P,  0,    0,   0 );  // pawn material is evaluated in eval.c
	 InitSinglePiece( N,  325,  1,   2 );
	 InitSinglePiece( B,  335,  1,   2 );
	 InitSinglePiece( R,  500,  2,   4 );
	 InitSinglePiece( Q,  975,  4,   7 );
	 InitSinglePiece(NO_TP, 0,  0,   0 );
};
      and
void sData::InitSinglePiece(int pc, int mat, int phase, int att) {
       matValue[pc]      = mat;
	 phaseValue[pc]    = phase;     
	 attMultiplier[pc] = att;      
}

  InitSinglePiece initializes matValue[P] = 0 ,IE pawn is worth zero.Because pawn's
 value depends from pawnMat, ie from general number of pawns and is evaluated in eval.c

  Let's calculate victim value :
 int victimValue = Data.matValue[ TpOnSq(p, tsq) ]; // get maximum gain from a capture
 and if TpOnSq(p, tsq )is P ( pawn ) when Data.matValue[P] will be zero.
 Also expression Data.matValue[ TpOnSq(p, tsq) ] is used in BadCapture function and there
 also Data.matValue[P] will be zero.

---------------------------------------------------------------------------------------------------------

  In file data.h we have :
 extern struct sData Data;
 This means that Data is the same structure as struct sData.
 extern means that structures are initialized elsewhere.
 sData initializes matValue[P] to 0.So Data.matValue[ P ] will be 0.
 Am I missing something ?

 In function 
 int sSelector::BadCapture(sPosition *p, int move) // last change 2012-03-06
 we have :
 // Good or equal captures not identified by the above conditions
 if (Data.matValue[TpOnSq(p, tsq)] >= Data.matValue[TpOnSq(p, fsq)] )
    return 0;

 If TpOnSq(p, fsq ) = K ( king ), when what Data.matValue[K] will be ?
 Of course TpOnSq(p, tsq ) != K ( king ), because king never ever will let be captured,ie
 move leading to current pos was undone at previous ply as illegal one.
 
----------------------------------------------------------------------------------------------------------------
 
   You wrote that you are to try NULL move in PV nodes if far away from root,IE
  when ply is big.My reasoning is:
   If we are in PV node - this means that until this position was reached both
  opponents have played their best moves at ply == 0, ply == 1 , ply == 2 ,...,
  until ( ply - 1 ).At this current ply we don't know initially if at this ply
  current player will find his best move for him or not.If returned score > alpha
  then BuildPv(pv, newPv, move) ,but if returned score >= beta or all returned
  scores <= alpha then principal variation truncates.So in all previous plies from
  0 until ( ply - 1 ) score was in interval ]alpha ; beta [ . This means that until
  this ply fight between opponents was in full swing. And until this ply is not very
  clear which opponent has advantage.What's why it is better not to truncate PV nodes.
  Also all nodes searched are split into PV and not PV ( either Cut or All nodes ).And
  vast majority of nodes are not PV nodes ( searched with minimal window,when
  alpha + 1 == beta ) , PV nodes ( when beta - alpha > 1 ) makes only small fraction from
  all nodes.If to make prunings at PV nodes when profit will be small and risk to
  prematurely truncate principal variation will be big.
   Of course there exists more than one principal variation when search progresses.
  Namely when :
     if (score > alpha) {
        alpha = score;
		if (isReporting) {
            if (isPvNode) BuildPv(pv, newPv, move);
                          .............
  then new principal variation occurs ( arises ).If you'll make null move at
  isPvNode then this new pv can be overlooked.It is very likely to happen,because
  when doing null move one condition is that
  current eval already should be >= beta.

   In Fruit / Toga emphasis is put on extending PV nodes and almost all reductions
  are done at non PV nodes.

   Some engines even do not allows to do lazy eval
  ( via Data.lazyMargin in Rodent ) in evaluation when beta - alpha > 1.
   Since number of PV nodes comparing with all types of nodes ( pv,cut,all ) is
  small most of the search goes in minimal windows ie when alpha + 1 == beta.
  CPU uses most of it's time when searching with minimal windows.What's why
  doing IID only at PV nodes will give minimal profit,ie will be almost useless.
  It is much better to do IID also at non PV nodes ( depth reduction no matters ) 
  than not doing IID at non PV nodes at all.


   Reducing at PV nodes can be added when engine already is playing perfectly,
  is finely tuned,has Elo rating over 2500;and when score seems not to beat alpha
  ( IE move is very late or int nodeEval = Eval.ReturnFast(p) is much below alpha.
  In order to be almost totally sure that new pv will never arise , IE that alpha has no chance
  to be improved.If alpha nevertheless was improved then we do full depth search-research.
  If to try to do null move in PV when maybe very strong verification should be used instead
  of this research,but this verification also is shit.

   Engine Bobcat does null move in PV nodes.But Bobcat also not perfect.

   If we write directly in code:
     if ( isPvNode )
        depth++;
   it won't work because too much extensions will be done and this will lead to
   a so-called "tree explosion".
   if ( isPvNode ) when we can consider recapture extension,extension when move
   is a capture and after that capture game transists into very late endgame.
   In Rodent is incrementally updated phase.This phase maybe can help whether to do
   this transition extension.      

------------------------------------------------------------------------------------------------------

  In Rodent we have :
  age = ((tt_date - entry->date) & 255) * 256 + 255 - (entry->depth / ONE_PLY);

  Let us define macro Age_Delta :
  #define Age_Delta(a, x ) (((a) - (x)) & 255 + 1 )

  When :
  age = ( Age_Delta(tt_date,entry->date ) << 8 ) - (entry->depth); // w/o dividing by ONE_PLY

  ( entry->depth ) will be at most ( maximum ) 256.
  Age_Delta(tt_date,entry->date ) << 8 will be at least ( minimum ) 256.
  So age >= 0 and all is correct.

--------------------------------------------------------------------------------------------------------------

  // EARLY EXIT CONDITIONS
  if ( IsRepetition(p) && ply ) return 0;

  Function IsRepetition(p) must look like this :

  int sSearcher::IsRepetition(sPosition *p)
    {
  int i;

  for (i = 4; i <= p->reversibleMoves && i <= p->head; i += 2)
    if (p->hashKey == p->repetitionList[p->head - i])
      return 1;
  return 0;
    }

  And then simply :
  if ( IsRepetition(p) ) return 0;
  Or :
  if ( !wasNull && IsRepetition(p) ) return 0;
   Because if wasNull then repetition was tested at previous ply.And since
  we are at current ply => at current ply also can't be repetition,because
  we are at the same pos after null move.
---------------------------------------------------------------------------------------------------------
   FUTILITY PRUNING can be done before DoMove(p, move, undoData).Then there is no need
for UndoMove(p, move, undoData).
But then we actually won't know if move which was futility pruned was
legal or not.

     // LOOP THROUGH THE MOVE LIST
  while ( move = Selector.NextMove(refutationSq, &flagMoveType) ) {
	depthChange    = 0;               // no depth modification so far
      // EXTENSIONS might be placed here

	// FUTILITY PRUNING 
	if ( flagCanPrune                 // flag is set
	&& !depthChange                   // we have not extended this move
	&& !flagMoveType                  // we are considering ordinary move
	&& movesTried > 0                 // we have found at least one legal move
	) {
         movesTried++;
         continue;
        }
     	DoMove(p, move, undoData);

	// RETRACT ILLEGAL MOVES
	if (IllegalPosition(p)) { 
		UndoMove(p, move, undoData); 
		continue; 
	}
	movesTried++;                     // increase legal move count
      flagIsReduced  = 0;               // this move has not been reduced (yet)
	History.OnMoveTried(move);
      // LATE MOVE PRUNING near the leaves (2012-04-02: two-tier approach)
      .............................................

      Now variable movesTried will count legal moves,but it
      can to grasp some illegal moves which were futility pruned.
      This bigger ( with illegal moves included ) movesTried can
      affect late move reduction,but who cares.LMR is done when not
      in check and futility also when not in check,so there can not be
      very many illegal moves.
      Statement
      // RETURN CORRECT CHECKMATE/STALEMATE SCORE
      if (best == -INF) return InCheck(p) ? -MATE + ply : 0;
      in my opinion will remain correct.


----------------------------------------------------------------------------------------

  TO TEST                                           

       About function int sSelector::MvvLva(sPosition *p, int move) in file selector.c .
   This function assigns too small values for captures with king.If we are capturing with
 king this means that king can not be re-captured by opponent and in expression :
 TpOnSq(p, Tsq(move)) * 6 + 5 - TpOnSq(p, Fsq(move))
 last member IE - TpOnSq(p, Fsq(move)) is needless.
   From enumeration
   enum ePiece {P, N, B, R, Q, K, NO_TP};
   follows that if TpOnSq(p, Fsq(move)) == K ( king ) then
 expression becomes :
 TpOnSq(p, Tsq(move)) * 6 + 5 - 5 or TpOnSq(p, Tsq(move)) * 6 .
 And we assign following values for captures with king:
    KxP = 0*6 = 0
    KxN = 1*6 = 6
    KxB = 2*6 = 12
    KxR = 3*6 = 18 
    KxQ = 4*6 = 24
    KxK = 5*6 = 30 ( impossible ,illegal position reached )

 Such a values are little bit too small.King is the best attacker and
 if we are capturing with king and move is legal ( not leads under check )
 then we already have captured piece in our pocket for nothing,because opponent
 won't be capable to re-capture our king.
  Maybe values should be :
    KxP = 6
    KxN = 12
    KxB = 18
    KxR = 24 
    KxQ = 30
 I don't know how to rise up these ( 0,6,12,18,24 ) values to ( 6,12,18,24,30 )
 without destroying other structures and without using too complicated formulas,
 IE without additional IFs.But know that it is easy.

-----------------------------------------------------------------------------------------

TO FIX

  We have :
  // TODO: will it be better to use real piece values?
  if (p->pc[Tsq(move)] != NO_PC)
    return TpOnSq(p, Tsq(move)) * 6 + 5 - TpOnSq(p, Fsq(move));

  This expression evaluates only captures,because
  must be p->pc[Tsq(move)] != NO_PC , ie we are moving to not empty
  square to = Tsq(move).But such a moves as a7xb8,b7xc8,e7xd8 etc also will be 
  evaluated due to this expression and no bonus is given for promoting.
  But promotions should be valued a bit higher.
  Maybe this is more correct :
  int sSelector::MvvLva(sPosition *p, int move)
  {
  int tactic_bonus = 0; // bonus for promotion to queen
  // TODO: will it be better to use real piece values?
  if (p->pc[Tsq(move)] != NO_PC){
  if ( (IsProm(move) && MoveType(move) ) == Q_PROM ) tactic_bonus = 100;
  return TpOnSq(p, Tsq(move)) * 6 + 5 - TpOnSq(p, Fsq(move)) + tactic_bonus;
                                }
  if (IsProm(move))
    return PromType(move) - 5;
  return 5;
  }
------------------------------------------------------------------------------------------------------------

TO CHECK

     About function int IsLegal(sPosition *p, int move) in file legal.c .
 Firstly we can add this line :
  // cannot capture king
  if ( ttp != NO_TP && ttp == K )
    return 0;
 This is not paranoia ,because theoretically this paranormality can be reached.

------------------------------------------------------------------------------------------------------------

TO CHECK

 Problem occurs with pawns moves when ftp == P ie when
 moving piece is pawn.
 We have :
  if (ftp == P) {
    if (side == WHITE) {
      if (Rank(fsq) == RANK_7 && !IsProm(move))
        return 0;
      if (tsq - fsq == 8)
        if (ttp == NO_TP)
          return 1;
              ................
  There moves like e2-e4,d2-d4,a2-a4 etc are omitted and treated as illegal.
 Not correct.There should be :
 if (ftp == P) {
    if (side == WHITE) {
      if (Rank(fsq) == RANK_7 && !IsProm(move))
        return 0;
      if (tsq - fsq == 8)
        if (ttp == NO_TP)
          return 1;
      if (tsq - fsq == 16)
        if (ttp == NO_TP)
        if ( Rank(fsq) == RANK_2 )
        if ( p->pc[tsq - 8] == NO_TP ) // or p->pc[fsq + 8] == NO_TP
          return 1;
            .....................
  The same of course if side == BLACK.
        if (tsq - fsq == -16)
        if (ttp == NO_TP)
        if ( Rank(fsq) == RANK_7 )
        if ( p->pc[tsq + 8] == NO_TP ) // or p->pc[fsq - 8] == NO_TP
          return 1;
             .....................
             
------------------------------------------------------------------------------------------------------------
     
  TO TEST   
     
     About function int sEvaluator::AdjustMaterial(sPosition *p) in file eval_material.c .
  I suggest this :

  if ( p->pcMat[WHITE]+ p->pcMat[BLACK] == 0 )
     result += ( p->pcCount[WHITE][P] -  p->pcCount[BLACK][P] ) *100;
     
  [code simplified - PK]  

  These are endgames when only pawns on board are left.In these cases
  having 1,2... pawns more than opponent is often decisive advantage.That's
  why  pawn's difference is multiplied by 100.
   Otherwise function int sEvaluator::GetMaterialScore(sPosition *p)  
  will count:
  score += pawnMat[p->pcCount[WHITE][P]];
  score -= pawnMat[p->pcCount[BLACK][P]];
  here uses :
  static const int pawnMat[9] = {-40, 90, 180, 270, 360, 450, 540, 630, 720};

  If white side has only 1 pawn and black side has only 2 pawns left then
  score += 90;
  score -= 180;
  And finally score -= 90;

  In above definition score will be decreased by 190 instead 90.This
  material score is more objective when there are only pawns left on the
  board.This modification can give approximately 17 Elo points.

  Also this trick is described in Ed Schroder programming tutorial where
 he describes Rebel chess engine.There is chapter called Pawn Ending.
   Below I made short extract from this tutorial:
       ---
 Rule no. 1 in pawn endings : the side with a pawn up will win the game.
 The below code ( or something similar ) is a must in every chess program:
  int pawn[] = { 0x00,0x00,0x100,0x200,0x300,0x400,0x500,0x600,0x700 };
  if (pawn_ending) 
   { score=score+pawn[number_of_white_pawns];
     score=score-pawn[number_of_black_pawns];
   }
 Effect : the difference in pawns is the bonus in pawns.
 Remark : the rule does not function in case of isolated double pawns,
 special code is needed to count isolated double pawns as 1 pawn before
 using the above formula.
      ---
 In essence this is the same bonus as I described above.In Rodent
 in case of pawn endgame array
 static const int pawnMat[9] = {-40, 90, 180, 270, 360, 450, 540, 630, 720};
 should be declared as :
 static const int Endgame_pawnMat[9] = { 0x00,0x00,0x100,0x200,0x300,0x400,0x500,0x600,0x700 };
 And latter array will be used when no other than pawns material is left on board.
 This case can be called 'peshechnik' in Russian language.
----------------------------------------------------------------------------------------------

   TO TEST

   Also when move is castle we update pstMg :
   p->pstMg[side] += Data.pstMg[side][R][tsq] - Data.pstMg[side][R][fsq];
   Here some bonuses can be added to pstMg in order to encourage castling.
   For instance :
   p->pstMg[side] += 20; // for long castling move O-O-O
   p->pstMg[side] += 30; // for short castling move O-O
   When undoing castle move these bonuses should be substracted of course.
   For p->pstEg[side] ( pst for Endgame ) bonuses are not given.
  
-------------------------------------------------------------------------------------------------------------
   
   WAITING (fixing is trivial, but would mean re-calibrating test results)
   
   In file parser.c .We have :
   } else if (strcmp(token, "ucinewgame") == 0) {
	  History.OnNewGame();
   }
   Here I suggest if (strcmp(token,"ucinewgame") == 0) {
        History.OnNewGame();
        TransTable.Clear(); // clear tt
   }
  This also clears tt_date ,ie sets tt_date = 0.
  And PawnTT here also should be cleared.
  
--------------------------------------------------------------------------------------------------------------

TO READ

  In file parser.c we have :
  void sParser::ParseGo(sPosition *p, char *ptr)
     {
  char token[80], bestmoveString[6];
  int pv[MAX_PLY];
  // TODO: move PV to search class
 .....................................
  Here is declared array pv[MAX_PLY].
 And below in the same function we have call :
 Searcher.Think(p, pv);
 Function Think is declared as :
 void sSearcher::Think(sPosition *p, int *pv)
 {
 ......................................
 Call Searcher.Think(p, pv) can be rewritten
 as Searcher.Think(p,&pv[0]), because pv is the
 same as &pv[0] and this &pv[0]is simply machine address.
 Only computer knows this &pv[0] value exactly.
 From Think we call function Iterate(p, pv).
 And from Iterate we call Search(p,0,........,pv ).
 So in Search when ply == 0 ( we are at the root )
 parameter int *pv will be initialized to pv, ie
 to &pv[0].Now when *pv is initialized to &pv[0],
 then pv will be equal to &pv[0] and *pv will be
 equal to value stored at this machine address (
 at pv or at &pv[0] ).In fact *pv will be equal to pv[0],
 ie *pv will be uninitialized, because array pv[] is uninitialized
 and pv[0],pv[1],... are all uninitialized.So *pv can be 0 ,but can be != 0.
 In order to test this theory I suggest to add debugging
 line(s) in function Search after line if (ply) *pv = 0; :
 if (ply) *pv = 0;
 if ( ply == 0 ) assert( *pv == 0 ); // debug
 or
 if (ply) *pv = 0;
 if ( ply == 0 )
 if ( *pv != 0 ) exit(0); // debug
  This test is needed because of the following reason:
 if at root ( when ply == 0 ) already *pv != 0 when 
 if at root search fails low then this *pv will remain
 non zero anyway ,ie will remain *pv != 0 and saving code will
 be incorrect,because *pv will be rubbish,and we will save
 fail low node as EXACT.
  // SAVE SEARCH RESULT IN TRANSPOSITION TABLE
  if (*pv) {
	History.OnGoodMove(p, *pv, depth / ONE_PLY, ply);
      TransTable.Store(p->hashKey, *pv, best, EXACT, depth, ply);
           }
      .........................
  Maybe array int pv[MAX_PLY] should be cleared ( all values set to
  0 ) after initialization.
  Or instead of 'if (ply) *pv = 0' write simply *pv = 0.
-------------------------------------------------------------------------------------------------------